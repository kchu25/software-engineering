<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/hypertext.css">
<link rel="icon" href="/assets/favicon.png">

   <title>Memory-Efficient Exclude-One Vectors in Julia</title>  
</head>
<body>
<header>
  <h1 style="color:#283747">software engineering</h1>
  <nav>
    <a href="/" class="current">Tags</a>
  | <a href="/blog/" >Notes</a>
  <hr/>
  </nav>
</header>


<!-- Content appended here -->
<div class="franklin-content"><h1 id="memory-efficient_exclude-one_vectors_in_julia"><a href="#memory-efficient_exclude-one_vectors_in_julia" class="header-anchor">Memory-Efficient Exclude-One Vectors in Julia</a></h1>
<h2 id="problem"><a href="#problem" class="header-anchor">Problem</a></h2>
<p>Generate &quot;exclude-one&quot; vectors &#40;complement of each element&#41; for multiple vectors, efficiently, for GPU operations.</p>
<h2 id="solution_flat_generator_with_views"><a href="#solution_flat_generator_with_views" class="header-anchor">Solution: Flat Generator with Views</a></h2>
<h3 id="basic_exclude-one_single_vector"><a href="#basic_exclude-one_single_vector" class="header-anchor">Basic Exclude-One &#40;Single Vector&#41;</a></h3>
<pre><code class="language-julia"># Returns generator of views - memory efficient
exclude_one&#40;x&#41; &#61; &#40;view&#40;x, &#91;1:i-1; i&#43;1:length&#40;x&#41;&#93;&#41; for i in 1:length&#40;x&#41;&#41;

# Usage:
x &#61; &#91;1, 2, 3, 4&#93;
for excluded in exclude_one&#40;x&#41;
    # excluded is a view, no copying
end

# Collect when needed for GPU:
result &#61; collect&#40;exclude_one&#40;x&#41;&#41;  # Vector of views</code></pre>
<h3 id="batch_exclude-one_multiple_vectors"><a href="#batch_exclude-one_multiple_vectors" class="header-anchor">Batch Exclude-One &#40;Multiple Vectors&#41;</a></h3>
<pre><code class="language-julia"># Flat generator - yields all exclude-one vectors sequentially
exclude_one_batch&#40;vectors&#41; &#61; &#40;
    view&#40;v, &#91;1:i-1; i&#43;1:length&#40;v&#41;&#93;&#41; 
    for v in vectors 
    for i in 1:length&#40;v&#41;
&#41;

# Order: &#91;v1\&#123;1&#125;, v1\&#123;2&#125;, ..., v2\&#123;1&#125;, v2\&#123;2&#125;, ..., v3\&#123;1&#125;, ...&#93;

# Usage:
vectors &#61; &#91;&#91;1,2,3&#93;, &#91;4,5,6&#93;, &#91;7,8,9&#93;&#93;
result &#61; collect&#40;exclude_one_batch&#40;vectors&#41;&#41;  # Vector of views</code></pre>
<h3 id="working_with_grouped_dataframes"><a href="#working_with_grouped_dataframes" class="header-anchor">Working with Grouped DataFrames</a></h3>
<pre><code class="language-julia">using DataFrames

# Single column
exclude_one_grouped&#40;gdf::GroupedDataFrame, col::Symbol&#41; &#61; &#40;
    view&#40;group&#91;&#33;, col&#93;, &#91;1:i-1; i&#43;1:nrow&#40;group&#41;&#93;&#41;
    for group in gdf
    for i in 1:nrow&#40;group&#41;
&#41;

# Multiple columns &#40;returns tuples of views&#41;
exclude_one_grouped_multi&#40;gdf::GroupedDataFrame, cols&#41; &#61; &#40;
    tuple&#40;&#40;view&#40;group&#91;&#33;, col&#93;, &#91;1:i-1; i&#43;1:nrow&#40;group&#41;&#93;&#41; for col in cols&#41;...&#41;
    for group in gdf
    for i in 1:nrow&#40;group&#41;
&#41;

# Multiple columns with named tuples
exclude_one_grouped_named&#40;gdf::GroupedDataFrame, cols&#41; &#61; &#40;
    NamedTuple&#123;tuple&#40;cols...&#41;&#125;&#40;
        tuple&#40;&#40;view&#40;group&#91;&#33;, col&#93;, &#91;1:i-1; i&#43;1:nrow&#40;group&#41;&#93;&#41; for col in cols&#41;...&#41;
    &#41;
    for group in gdf
    for i in 1:nrow&#40;group&#41;
&#41;

# Usage:
df &#61; DataFrame&#40;category &#61; &#91;1,1,1,2,2,2&#93;, value &#61; &#91;10,20,30,40,50,60&#93;&#41;
gdf &#61; groupby&#40;df, :category&#41;
result &#61; collect&#40;exclude_one_grouped&#40;gdf, :value&#41;&#41;</code></pre>
<h2 id="key_properties"><a href="#key_properties" class="header-anchor">Key Properties</a></h2>
<h3 id="memory_efficiency"><a href="#memory_efficiency" class="header-anchor">Memory Efficiency</a></h3>
<ul>
<li><p><strong>Views</strong>: No data copying until needed</p>
</li>
<li><p><strong>Generators</strong>: Lazy evaluation - elements created on demand</p>
</li>
<li><p><strong>length&#40;&#41;</strong> on views: Allocation-free &#40;just reads metadata&#41;</p>
</li>
</ul>
<h3 id="generator_vs_nested_generator"><a href="#generator_vs_nested_generator" class="header-anchor">Generator vs Nested Generator</a></h3>
<pre><code class="language-julia"># Flat generator &#40;what we want&#41;:
&#40;f&#40;v,i&#41; for v in vectors for i in 1:length&#40;v&#41;&#41;
# → Single-level: &#91;item1, item2, item3, ...&#93;

# Nested generator &#40;different structure&#41;:
&#40;&#40;f&#40;v,i&#41; for i in 1:length&#40;v&#41;&#41; for v in vectors&#41;
# → Two-level: &#91;&#91;items from v1&#93;, &#91;items from v2&#93;, ...&#93;</code></pre>
<h3 id="iteration_order"><a href="#iteration_order" class="header-anchor">Iteration Order</a></h3>
<p>The leftmost <code>for</code> is the outer loop:</p>
<pre><code class="language-julia">for v in vectors          # Processes each vector completely
    for i in 1:length&#40;v&#41;  # Before moving to next vector
        yield view&#40;v, ...&#41;
    end
end</code></pre>
<h2 id="converting_to_gpu_format"><a href="#converting_to_gpu_format" class="header-anchor">Converting to GPU Format</a></h2>
<pre><code class="language-julia"># Collect to vector of views &#40;minimal allocation&#41;:
gpu_input &#61; collect&#40;exclude_one_batch&#40;vectors&#41;&#41;

# Or fully materialize if needed:
gpu_input &#61; &#91;collect&#40;v&#41; for v in exclude_one_batch&#40;vectors&#41;&#93;

# Convert to matrix for GPU &#40;if needed&#41;:
matrix_form &#61; hcat&#40;collect.&#40;exclude_one&#40;x&#41;&#41;...&#41;&#39;</code></pre>
<h2 id="performance_notes"><a href="#performance_notes" class="header-anchor">Performance Notes</a></h2>
<ul>
<li><p>Views add negligible overhead</p>
</li>
<li><p>Generators don&#39;t allocate until iterated</p>
</li>
<li><p>Indexing into views is allocation-free</p>
</li>
<li><p>Only pay memory cost when you <code>collect&#40;&#41;</code> for GPU transfer</p>
</li>
</ul>
<h3 id="accessing_length_of_generator_elements"><a href="#accessing_length_of_generator_elements" class="header-anchor">Accessing Length of Generator Elements</a></h3>
<pre><code class="language-julia">gen &#61; exclude_one_batch&#40;vectors&#41;

# Length check is allocation-free:
for v in gen
    n &#61; length&#40;v&#41;  # NO allocation - just reads view metadata
    # Views store indices, length&#40;&#41; just counts them
end

# This is safe and efficient:
lengths &#61; &#91;length&#40;v&#41; for v in gen&#93;  # Only allocates the integer vector

# Views maintain metadata:
x &#61; &#91;1, 2, 3, 4, 5&#93;
v &#61; view&#40;x, &#91;1, 2, 4, 5&#93;&#41;
length&#40;v&#41;  # → 4 &#40;allocation-free, reads stored indices&#41;
v&#91;1&#93;       # → 1 &#40;allocation-free, indexed access to parent&#41;</code></pre>
<p><strong>Important</strong>: <code>length&#40;&#41;</code> on a view &#40;SubArray&#41; just reads metadata - the view stores its indices and parent array pointer, so getting the length is just counting the indices. No data materialization occurs.</p>
<h3 id="generator_laziness_-_views_created_on_demand"><a href="#generator_laziness_-_views_created_on_demand" class="header-anchor">Generator Laziness - Views Created On Demand</a></h3>
<pre><code class="language-julia">gen &#61; exclude_one_batch&#40;vectors&#41;  # NO views created yet&#33;

# Views are created one-at-a-time during iteration:
for v in gen
    # v is created RIGHT NOW, used, then can be garbage collected
    # Next iteration creates the next view
end

# Only when you collect&#40;&#41;:
result &#61; collect&#40;gen&#41;  # NOW all views are created and stored

# This means:
gen1 &#61; exclude_one_batch&#40;vectors&#41;  # Virtually free
gen2 &#61; exclude_one_batch&#40;vectors&#41;  # Also virtually free
# No duplication until you iterate/collect&#33;</code></pre>
<p><strong>Key insight</strong>: The generator is just a recipe. Views are created <strong>lazily</strong> as you iterate, one at a time. If you iterate through a generator twice, the views are created twice &#40;but this is cheap since views are just metadata&#41;. Only <code>collect&#40;&#41;</code> materializes all views at once into memory.all views at once into memory.</p>
<div class="page-foot">
    Contact me by <a href="mailto:skchu@wustl.edu">E-mail</a> | <a href="https://github.com/kchu25">Github</a> | <a href="https://www.linkedin.com/in/kchu1/">Linkedin</a>
    <br>
    This work is licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.  Last modified: October 17, 2025.
    <br>
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
