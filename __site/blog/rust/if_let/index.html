<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/hypertext.css">
<link rel="icon" href="/assets/favicon.png">

   <title>if let and let else: When Match Is Overkill</title>  
</head>
<body>
<header>
  <h1 style="color:#283747">software engineering</h1>
  <nav>
    <a href="/" class="current">Tags</a>
  | <a href="/blog/" >Notes</a>
  <hr/>
  </nav>
</header>


<!-- Content appended here -->
<div class="franklin-content"><h1 id="if_let_and_let_else_when_match_is_overkill"><a href="#if_let_and_let_else_when_match_is_overkill" class="header-anchor"><code>if let</code> and <code>let else</code>: When Match Is Overkill</a></h1>
<p>Sometimes you only care about <strong>one</strong> pattern. Writing a full <code>match</code> for that feels like overkill.</p>
<hr />
<h2 id="the_problem_too_much_boilerplate"><a href="#the_problem_too_much_boilerplate" class="header-anchor">The Problem: Too Much Boilerplate</a></h2>
<p>Say you have an <code>Option&lt;u8&gt;</code> and you only want to do something if it&#39;s <code>Some</code>:</p>
<pre><code class="language-rust">let config_max &#61; Some&#40;3u8&#41;;

match config_max &#123;
    Some&#40;max&#41; &#61;&gt; println&#33;&#40;&quot;The maximum is configured to be &#123;&#125;&quot;, max&#41;,
    _ &#61;&gt; &#40;&#41;,  // Do nothing for None... but we HAVE to write this&#33;
&#125;</code></pre>
<p>That <code>_ &#61;&gt; &#40;&#41;</code> is annoying. You&#39;re forced to handle a case you don&#39;t care about, just to satisfy the compiler&#39;s exhaustiveness requirement.</p>
<hr />
<h2 id="the_solution_if_let"><a href="#the_solution_if_let" class="header-anchor">The Solution: <code>if let</code></a></h2>
<p><code>if let</code> lets you match on just one pattern and ignore everything else:</p>
<pre><code class="language-rust">let config_max &#61; Some&#40;3u8&#41;;

if let Some&#40;max&#41; &#61; config_max &#123;
    println&#33;&#40;&quot;The maximum is configured to be &#123;&#125;&quot;, max&#41;;
&#125;</code></pre>
<p>Much cleaner&#33; No boilerplate <code>_ &#61;&gt; &#40;&#41;</code> needed.</p>
<hr />
<h2 id="wait_why_if_let_why_not_just_if"><a href="#wait_why_if_let_why_not_just_if" class="header-anchor">Wait, Why <code>if let</code>? Why Not Just <code>if</code>?</a></h2>
<p>This syntax looks weird at first. Let&#39;s understand why it exists.</p>
<h3 id="problem_1_regular_if_needs_a_boolean"><a href="#problem_1_regular_if_needs_a_boolean" class="header-anchor">Problem 1: Regular <code>if</code> needs a boolean</a></h3>
<pre><code class="language-rust">let x &#61; Some&#40;5&#41;;

// ❌ Doesn&#39;t work - Option is not true/false
if x &#123;
    println&#33;&#40;&quot;has value&quot;&#41;;
&#125;</code></pre>
<p><code>if</code> only works with booleans. <code>Some&#40;5&#41;</code> isn&#39;t <code>true</code> or <code>false</code>, it&#39;s an <code>Option</code>.</p>
<h3 id="problem_2_checking_equality_doesnt_give_you_the_inner_value"><a href="#problem_2_checking_equality_doesnt_give_you_the_inner_value" class="header-anchor">Problem 2: Checking equality doesn&#39;t give you the inner value</a></h3>
<pre><code class="language-rust">let x &#61; Some&#40;5&#41;;

// This compiles, but...
if x &#61;&#61; Some&#40;5&#41; &#123;
    // I know x is Some&#40;5&#41;, but I can&#39;t USE the 5&#33;
    // The value is trapped inside the Option.
&#125;</code></pre>
<p>Even if you confirm it&#39;s <code>Some</code>, you haven&#39;t <strong>extracted</strong> what&#39;s inside.</p>
<h3 id="what_we_actually_need_test_and_extract"><a href="#what_we_actually_need_test_and_extract" class="header-anchor">What we actually need: Test AND Extract</a></h3>
<p>We need to do two things:</p>
<ol>
<li><p><strong>Check:</strong> Is this a <code>Some</code>?</p>
</li>
<li><p><strong>Extract:</strong> If yes, give me the value inside</p>
</li>
</ol>
<p>That&#39;s exactly what <code>if let</code> does:</p>
<pre><code class="language-rust">let x &#61; Some&#40;5&#41;;

if let Some&#40;value&#41; &#61; x &#123;
    //   ^^^^^^^^^^^^   Tests: is x a Some?
    //        ^^^^^     Extracts: pull out the inner value, call it &#96;value&#96;
    println&#33;&#40;&quot;Got: &#123;&#125;&quot;, value&#41;;  // Now I can use it&#33;
&#125;</code></pre>
<hr />
<h2 id="why_does_mean_matches_not_assignment"><a href="#why_does_mean_matches_not_assignment" class="header-anchor">Why Does <code>&#61;</code> Mean &quot;Matches&quot;? &#40;Not Assignment&#33;&#41;</a></h2>
<p>This is the confusing part. In <code>if let Some&#40;value&#41; &#61; x</code>, the <code>&#61;</code> is <strong>not</strong> assignment.</p>
<h3 id="the_in_normal_let_statements"><a href="#the_in_normal_let_statements" class="header-anchor">The <code>&#61;</code> in normal <code>let</code> statements</a></h3>
<p>In a regular <code>let</code>, <code>&#61;</code> means &quot;bind this pattern to this value&quot;:</p>
<pre><code class="language-rust">let x &#61; 5;              // Simple: x becomes 5
let &#40;a, b&#41; &#61; &#40;1, 2&#41;;    // Pattern: extract 1 into a, 2 into b
let Point &#123; x, y &#125; &#61; p; // Pattern: extract fields into x and y</code></pre>
<p>Notice: the <strong>left side is a pattern</strong>, the right side is a value. Rust &quot;destructures&quot; the right side into the left side&#39;s pattern.</p>
<h3 id="the_in_if_let_is_the_same_idea"><a href="#the_in_if_let_is_the_same_idea" class="header-anchor">The <code>&#61;</code> in <code>if let</code> is the same idea</a></h3>
<pre><code class="language-rust">if let Some&#40;value&#41; &#61; x &#123;
//     ^^^^^^^^^^^   ^
//     pattern       value to destructure</code></pre>
<p>It means: &quot;Try to destructure <code>x</code> into the pattern <code>Some&#40;value&#41;</code>. If it fits, enter the block.&quot;</p>
<h3 id="think_of_it_as_trying_a_let"><a href="#think_of_it_as_trying_a_let" class="header-anchor">Think of it as &quot;trying&quot; a <code>let</code></a></h3>
<pre><code class="language-rust">// Regular let - MUST succeed &#40;or compile error&#41;
let Some&#40;value&#41; &#61; x;  // ❌ Compile error if x might be None&#33;

// if let - TRY to match, enter block only if successful
if let Some&#40;value&#41; &#61; x &#123;  // ✓ If x is Some, extract; if None, skip block
    // ...
&#125;</code></pre>
<p>The <code>if let</code> is a <strong>conditional</strong> pattern match. The <code>&#61;</code> means &quot;destructure into this pattern&quot;, and the <code>if</code> means &quot;only if it succeeds.&quot;</p>
<hr />
<h2 id="the_full_mental_model"><a href="#the_full_mental_model" class="header-anchor">The Full Mental Model</a></h2>
<pre><code class="language-julia">if let PATTERN &#61; VALUE &#123;
       ^^^^^^    ^^^^^
       │         └── The value you&#39;re inspecting
       └── The shape you expect, with names for the pieces</code></pre>
<p><strong>Step by step:</strong></p>
<ol>
<li><p>Rust looks at <code>VALUE</code></p>
</li>
<li><p>Asks: &quot;Does this match <code>PATTERN</code>?&quot;</p>
</li>
<li><p>If yes: bind the extracted pieces to variable names, run the block</p>
</li>
<li><p>If no: skip the block entirely</p>
</li>
</ol>
<pre><code class="language-rust">let my_option &#61; Some&#40;42&#41;;

if let Some&#40;n&#41; &#61; my_option &#123;
    // Step 1: Look at my_option → it&#39;s Some&#40;42&#41;
    // Step 2: Does Some&#40;42&#41; match Some&#40;n&#41;? YES
    // Step 3: Bind 42 to n, enter this block
    println&#33;&#40;&quot;&#123;&#125;&quot;, n&#41;;  // prints 42
&#125;

let my_option &#61; None;

if let Some&#40;n&#41; &#61; my_option &#123;
    // Step 1: Look at my_option → it&#39;s None
    // Step 2: Does None match Some&#40;n&#41;? NO
    // Step 4: Skip this entire block
    println&#33;&#40;&quot;&#123;&#125;&quot;, n&#41;;  // never runs
&#125;</code></pre>
<hr />
<h2 id="how_if_let_works_the_equivalence"><a href="#how_if_let_works_the_equivalence" class="header-anchor">How <code>if let</code> Works &#40;The Equivalence&#41;</a></h2>
<p>The syntax is:</p>
<pre><code class="language-rust">if let PATTERN &#61; EXPRESSION &#123;
    // Code runs only if PATTERN matches
&#125;</code></pre>
<p>It&#39;s basically <strong>syntax sugar</strong> for a <code>match</code> with one arm you care about and a catch-all that does nothing:</p>
<pre><code class="language-rust">// These two are equivalent:

// if let version
if let Some&#40;x&#41; &#61; my_option &#123;
    println&#33;&#40;&quot;&#123;&#125;&quot;, x&#41;;
&#125;

// match version
match my_option &#123;
    Some&#40;x&#41; &#61;&gt; println&#33;&#40;&quot;&#123;&#125;&quot;, x&#41;,
    _ &#61;&gt; &#40;&#41;,
&#125;</code></pre>
<hr />
<h2 id="if_let_with_else"><a href="#if_let_with_else" class="header-anchor"><code>if let</code> with <code>else</code></a></h2>
<p>What if you want to do something when it <strong>doesn&#39;t</strong> match? Use <code>else</code>:</p>
<pre><code class="language-rust">let coin &#61; Coin::Quarter&#40;UsState::Alaska&#41;;

if let Coin::Quarter&#40;state&#41; &#61; coin &#123;
    println&#33;&#40;&quot;State quarter from &#123;:?&#125;&#33;&quot;, state&#41;;
&#125; else &#123;
    println&#33;&#40;&quot;Not a quarter&quot;&#41;;
&#125;</code></pre>
<p>This is equivalent to:</p>
<pre><code class="language-rust">match coin &#123;
    Coin::Quarter&#40;state&#41; &#61;&gt; println&#33;&#40;&quot;State quarter from &#123;:?&#125;&#33;&quot;, state&#41;,
    _ &#61;&gt; println&#33;&#40;&quot;Not a quarter&quot;&#41;,
&#125;</code></pre>
<hr />
<h2 id="real_example_counting_non-quarters"><a href="#real_example_counting_non-quarters" class="header-anchor">Real Example: Counting Non-Quarters</a></h2>
<pre><code class="language-rust">let mut count &#61; 0;

// With match
match coin &#123;
    Coin::Quarter&#40;state&#41; &#61;&gt; println&#33;&#40;&quot;State quarter from &#123;:?&#125;&#33;&quot;, state&#41;,
    _ &#61;&gt; count &#43;&#61; 1,
&#125;

// With if let &#40;same behavior&#41;
if let Coin::Quarter&#40;state&#41; &#61; coin &#123;
    println&#33;&#40;&quot;State quarter from &#123;:?&#125;&#33;&quot;, state&#41;;
&#125; else &#123;
    count &#43;&#61; 1;
&#125;</code></pre>
<p>Both work. Use whichever reads better in context.</p>
<hr />
<h2 id="the_trade-off_no_exhaustiveness_checking"><a href="#the_trade-off_no_exhaustiveness_checking" class="header-anchor">The Trade-Off: No Exhaustiveness Checking</a></h2>
<p><strong>With <code>match</code>:</strong> The compiler ensures you handle every case. Forget one? Compilation error.</p>
<p><strong>With <code>if let</code>:</strong> You&#39;re explicitly saying &quot;I only care about this one pattern.&quot; The compiler won&#39;t warn you about unhandled cases.</p>
<p>Choose based on your situation:</p>
<ul>
<li><p>Use <code>match</code> when you need to handle multiple cases or want the compiler to catch forgotten cases</p>
</li>
<li><p>Use <code>if let</code> when you genuinely only care about one pattern</p>
</li>
</ul>
<hr />
<h2 id="let_else_staying_on_the_happy_path"><a href="#let_else_staying_on_the_happy_path" class="header-anchor"><code>let else</code>: Staying on the &quot;Happy Path&quot;</a></h2>
<p>Sometimes you want to extract a value or <strong>bail out early</strong>. Here&#39;s a common pattern:</p>
<pre><code class="language-rust">fn describe_state_quarter&#40;coin: Coin&#41; -&gt; Option&lt;String&gt; &#123;
    // Extract the state, or return early if it&#39;s not a quarter
    let state &#61; if let Coin::Quarter&#40;state&#41; &#61; coin &#123;
        state
    &#125; else &#123;
        return None;
    &#125;;

    // Now we can use &#96;state&#96; knowing it exists
    if state.existed_in&#40;1900&#41; &#123;
        Some&#40;format&#33;&#40;&quot;&#123;:?&#125; is pretty old, for America&#33;&quot;, state&#41;&#41;
    &#125; else &#123;
        Some&#40;format&#33;&#40;&quot;&#123;:?&#125; is relatively new.&quot;, state&#41;&#41;
    &#125;
&#125;</code></pre>
<p>This works, but it&#39;s a bit clunky. One branch returns a value, the other returns from the function entirely.</p>
<h3 id="let_else_makes_this_cleaner"><a href="#let_else_makes_this_cleaner" class="header-anchor"><code>let else</code> Makes This Cleaner</a></h3>
<p>Rust has <code>let else</code> for exactly this pattern:</p>
<pre><code class="language-rust">fn describe_state_quarter&#40;coin: Coin&#41; -&gt; Option&lt;String&gt; &#123;
    let Coin::Quarter&#40;state&#41; &#61; coin else &#123;
        return None;  // Must diverge &#40;return, break, panic, etc.&#41;
    &#125;;

    // &#96;state&#96; is now available here&#33;
    if state.existed_in&#40;1900&#41; &#123;
        Some&#40;format&#33;&#40;&quot;&#123;:?&#125; is pretty old, for America&#33;&quot;, state&#41;&#41;
    &#125; else &#123;
        Some&#40;format&#33;&#40;&quot;&#123;:?&#125; is relatively new.&quot;, state&#41;&#41;
    &#125;
&#125;</code></pre>
<p><strong>Read it as:</strong> &quot;Let this pattern match, otherwise do this &#40;and exit&#41;.&quot;</p>
<h3 id="how_let_else_works"><a href="#how_let_else_works" class="header-anchor">How <code>let else</code> Works</a></h3>
<pre><code class="language-rust">let PATTERN &#61; EXPRESSION else &#123;
    // This block MUST diverge &#40;return, break, continue, panic&#33;, etc.&#41;
    // It cannot just &quot;fall through&quot; to the next line
&#125;;
// If the pattern matched, the bound variables are available here</code></pre>
<p>The key rule: <strong>the <code>else</code> block must diverge</strong>. It can&#39;t just do nothing—it must exit the current flow &#40;return from function, break from loop, panic, etc.&#41;.</p>
<h3 id="why_happy_path"><a href="#why_happy_path" class="header-anchor">Why &quot;Happy Path&quot;?</a></h3>
<p>With <code>let else</code>, your main code stays at the top level, reading straight down:</p>
<pre><code class="language-rust">fn process&#40;input: Option&lt;Data&gt;&#41; -&gt; Result&lt;Output, Error&gt; &#123;
    let Some&#40;data&#41; &#61; input else &#123;
        return Err&#40;Error::NoInput&#41;;
    &#125;;

    let validated &#61; validate&#40;data&#41; else &#123;
        return Err&#40;Error::Invalid&#41;;
    &#125;;

    let result &#61; compute&#40;validated&#41; else &#123;
        return Err&#40;Error::ComputeFailed&#41;;
    &#125;;

    Ok&#40;result&#41;
&#125;</code></pre>
<p>Each <code>let else</code> is a checkpoint: &quot;if this doesn&#39;t work, bail out.&quot; The main logic flows straight down without nesting deeper and deeper.</p>
<hr />
<h2 id="when_to_use_what"><a href="#when_to_use_what" class="header-anchor">When to Use What?</a></h2>
<table><tr><th align="right">Situation</th><th align="right">Use</th></tr><tr><td align="right">Handle all cases explicitly</td><td align="right"><code>match</code></td></tr><tr><td align="right">Only care about one case, ignore the rest</td><td align="right"><code>if let</code></td></tr><tr><td align="right">One case &#43; do something for everything else</td><td align="right"><code>if let</code> &#43; <code>else</code></td></tr><tr><td align="right">Extract value or bail out early</td><td align="right"><code>let else</code></td></tr></table>
<hr />
<h2 id="quick_comparison"><a href="#quick_comparison" class="header-anchor">Quick Comparison</a></h2>
<pre><code class="language-rust">let maybe_value: Option&lt;i32&gt; &#61; Some&#40;42&#41;;

// match - handles all cases explicitly
match maybe_value &#123;
    Some&#40;v&#41; &#61;&gt; println&#33;&#40;&quot;Got &#123;&#125;&quot;, v&#41;,
    None &#61;&gt; println&#33;&#40;&quot;Got nothing&quot;&#41;,
&#125;

// if let - only care about Some
if let Some&#40;v&#41; &#61; maybe_value &#123;
    println&#33;&#40;&quot;Got &#123;&#125;&quot;, v&#41;;
&#125;

// if let &#43; else - care about Some, do something else for None
if let Some&#40;v&#41; &#61; maybe_value &#123;
    println&#33;&#40;&quot;Got &#123;&#125;&quot;, v&#41;;
&#125; else &#123;
    println&#33;&#40;&quot;Got nothing&quot;&#41;;
&#125;

// let else - extract or bail out
fn use_value&#40;opt: Option&lt;i32&gt;&#41; -&gt; i32 &#123;
    let Some&#40;v&#41; &#61; opt else &#123;
        return -1;  // bail out with default
    &#125;;
    v * 2  // use the extracted value
&#125;</code></pre>
<hr />
<h2 id="summary"><a href="#summary" class="header-anchor">Summary</a></h2>
<ul>
<li><p><strong><code>if let</code></strong> &#61; &quot;If this pattern matches, do something&quot; &#40;ignore non-matches&#41;</p>
</li>
<li><p><strong><code>if let</code> &#43; <code>else</code></strong> &#61; &quot;If this pattern matches, do X; otherwise do Y&quot;</p>
</li>
<li><p><strong><code>let else</code></strong> &#61; &quot;Extract this value, or bail out early&quot;</p>
</li>
</ul>
<p>All three are shortcuts for common <code>match</code> patterns. They make your code more concise when you don&#39;t need full pattern matching power.</p>
<p><strong>Remember:</strong> <code>if let</code> trades exhaustiveness checking for conciseness. Use <code>match</code> when you want the compiler to ensure you&#39;ve handled all cases.</p>
<div class="page-foot">
    Contact me by <a href="mailto:skchu@wustl.edu">E-mail</a> | <a href="https://github.com/kchu25">Github</a> | <a href="https://www.linkedin.com/in/kchu1/">Linkedin</a>
    <br>
    This work is licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.  Last modified: January 30, 2026.
    <br>
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
