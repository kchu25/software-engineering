@def title = "Rust Enums, Match, and if let: The Confusing Parts Explained"
@def published = "29 January 2026"
@def tags = ["rust"]

# Rust Enums, Match, and if let: The Confusing Parts Explained

This page addresses the confusing terminology and concepts around enums, match, and `if let` in Rust.

---

## Structs vs Enums: Fields vs Variants

### Why are they called different things?

Because they represent **fundamentally different relationships**:

**Struct = AND (all fields exist together)**

```rust
struct Point {
    x: i32,  // field
    y: i32,  // field
}

let p = Point { x: 5, y: 10 };
// p has BOTH x AND y simultaneously
// A Point ALWAYS has all its fields
```

**Enum = OR (only one variant at a time)**

```rust
enum Shape {
    Circle(f64),          // variant
    Rectangle(f64, f64),  // variant
}

let s = Shape::Circle(5.0);
// s is EITHER a Circle OR a Rectangle
// Never both at the same time
```

**Summary:**
- **Field** = "one piece of a whole" (all fields exist together)
- **Variant** = "one possibility among many" (only one exists at a time)

---

## Creating Enum Values: You're Not "Creating an Enum"

This terminology trips people up:

```rust
// DEFINING the enum TYPE (done once, like a blueprint)
enum Option<T> {
    Some(T),
    None,
}

// CREATING VALUES of that type (done many times)
let x = Some(5);   // x is a VALUE, specifically the Some VARIANT
let y = None;      // y is a VALUE, specifically the None VARIANT
```

**You don't "create an enum."** You create a **value** that is one of the enum's **variants**.

It's like `bool`:

```rust
let a: bool = true;   // true is a VALUE of type bool
let b: bool = false;  // false is a VALUE of type bool

let x: Option<i32> = Some(5);  // Some(5) is a VALUE of type Option<i32>
let y: Option<i32> = None;     // None is a VALUE of type Option<i32>
```

---

## Variant Data is Like an Anonymous Struct (Already Defined)

Here's a key insight: **the data inside a variant is defined inline**—you don't need to define it separately.

```rust
// When you define the enum, you also define what each variant holds
enum Message {
    Move { x: i32, y: i32 },  // ← This IS the definition. Like an anonymous struct.
    Write(String),            // ← Holds a String. No separate definition needed.
}

// To use it, just create a value:
let msg = Message::Move { x: 10, y: 20 };
let msg2 = Message::Write(String::from("hello"));
```

### `Option` and `Some`: Already Defined for You

`Option<T>` is defined in Rust's standard library:

```rust
// Rust already defined this (you don't write this yourself):
enum Option<T> {
    Some(T),   // ← Variant that holds one value of type T
    None,      // ← Variant that holds nothing
}
```

So when you write `Some(5)`, you're:
1. Using the `Some` variant (already defined in `Option`)
2. Putting `5` into it

```rust
let x = Some(5);          // Create a Some holding 5
let name = Some("Alice"); // Create a Some holding "Alice"

// Later, extract it with if let:
if let Some(n) = x {
    println!("Got: {}", n);  // n is 5
}
```

You didn't have to define `Some` or declare what it holds—**it's already defined as part of `Option<T>`**, and `T` becomes whatever type you put in.

### Comparison: What You Define vs. What's Pre-defined

| Enum | Who defines it? | Example usage |
|------|-----------------|---------------|
| `Option<T>` | Rust standard library | `Some(42)`, `None` |
| `Result<T, E>` | Rust standard library | `Ok(value)`, `Err(error)` |
| `Message` (custom) | You define it | `Message::Write(s)` |

---

## Why Do Enum Variants Hold Data?

In many languages, enums are just named integers:

```c
// C enum - just numbers with names
enum Color { RED, GREEN, BLUE };  // RED=0, GREEN=1, BLUE=2
```

Rust's enums are different: **each variant can hold its own data**.

### Why is this useful?

Imagine an IP address that can be either IPv4 (4 numbers) or IPv6 (a string):

```rust
// ❌ Without data-holding variants: awkward
struct IpAddr {
    v4_octets: Option<[u8; 4]>,  // Only used if v4
    v6_addr: Option<String>,     // Only used if v6
    is_v4: bool,                 // Which one is it?
}

// ✅ With data-holding variants: clean
enum IpAddr {
    V4(u8, u8, u8, u8),  // Holds 4 numbers
    V6(String),          // Holds a string
}
```

Each variant carries exactly the data it needs. No wasted `Option` fields, no separate `is_v4` flag.

---

## Match: Why Does It "Return" a Value?

**`match` doesn't "return"—it's an expression.**

In C, `switch` is a statement (just does things):

```c
int value;
switch (coin) {
    case PENNY: value = 1; break;
    case NICKEL: value = 5; break;
}
```

In Rust, `match` is an expression (produces a value):

```rust
let value = match coin {
    Coin::Penny => 1,
    Coin::Nickel => 5,
    Coin::Dime => 10,
    Coin::Quarter => 25,
};
```

**Why?** Less repetition, guaranteed initialization, and you can use it anywhere a value is needed.

---

## if let: What Is It Actually Doing?

### Why not just use `if`?

Regular `if` needs a boolean. You can't do:

```rust
let x = Some(5);
if x {  // ❌ Error: Option is not true/false!
```

And even checking equality doesn't let you get the inner value:

```rust
if x == Some(5) {
    // I know x is Some(5), but I can't ACCESS the 5!
}
```

### What `if let` actually does: Check variant + Assign

```rust
if let Some(value) = x {
    println!("{}", value);
}
```

This does **two things**:

1. **Checks the variant:** Is `x` the `Some` variant?
2. **Assigns:** If yes, put the inner value into `value`

**Read it as:** "If `x` is the `Some` variant, assign its contents to `value`."

### The `=` is doing both matching AND assigning

It's not just assignment, and it's not just matching. It's:

1. **Match the variant:** Is this a `Some`?
2. **If yes, assign:** `value = (the inner contents)`

If `x` is `None`, there's nothing inside to assign, so the whole thing fails and we skip the block.

### A more explicit way to read it

```rust
if let Some(value) = x {
    // ...
}

// Means:
// "If x is the Some variant,
//  assign its contents to value,
//  and run this block."
```

---

## Why Is `=` Used for Pattern Matching?

This syntax comes from Rust's destructuring assignments:

```rust
let (a, b) = (1, 2);     // Destructure tuple: a=1, b=2
let Point { x, y } = p;  // Destructure struct: x=p.x, y=p.y
```

The **left side is a pattern** (a shape with "holes" to fill), the right side is a value. Rust fills in the holes.

`if let` extends this idea:

```rust
if let Some(value) = x
//     ^^^^^-----^
//     Pattern with a "hole" called value
```

If `x` fits this shape (`Some(something)`), Rust fills the hole: `value = something`.

If `x` doesn't fit (it's `None`), there's nothing to fill, so we skip the block.

**So `=` means:** "Try to destructure the right side into the left side's pattern."

---

## The Complete Mental Model

### Enum
- An enum is a **type** with multiple **variants**
- A value of an enum type is **one specific variant**
- Variants can hold data (each variant has its own shape)

### Match
- Checks which **variant** a value is
- Runs the code for the matching arm
- Is an **expression** (produces a value)
- Only **one arm** runs (no fall-through)

### if let
- **Checks:** Is this value the specified variant?
- **Assigns:** If yes, put the inner contents into variables
- Skips the block if the variant doesn't match
- Shortcut for a `match` where you only care about one case

### The `=` in patterns
- **Not** equality checking (`==`)
- **Not** simple assignment in one direction
- Means: "destructure the right side into the left side's pattern"
- For `if let`: "try to destructure; if successful, run the block"

---

## Quick Reference

| Concept | What it means |
|---------|---------------|
| Struct field | A piece of data that's always present |
| Enum variant | One possibility among several (only one exists at a time) |
| `Some(5)` | A **value** of type `Option`, specifically the `Some` variant |
| `match` | Check which variant, run corresponding code, return a value |
| `if let Some(x) = y` | "If y is Some, assign contents to x and run this block" |
| `=` in patterns | "Destructure right side into left side's pattern" |
